<?php
/**
 * Coffee Framework
 *
 * PHP Version 5.3
 *
 * LICENSE
 *
 * 본 프로그램은 New BSD License 를 기본으로 하고 있지만 약간 다른 제약조건을 가지고 있습니다. 
 * 함께 제공된 license file 인  doc/LICENSE 를 꼭 확인하시길 바랍니다.
 *
 * This Source is subject to the New BSD License with SOME CONSTRAINT that is boudled
 * with this package in the file doc/LICENSE 
 *
 * @category   CF
 * @package    CF_config
 * @author     그네 Jung Sik, Park <ccooffeee@hotmail.com>
 * @copyright  Copyright (c) 2009 - 2012 Jung Sik, Park <ccooffeee@hotmail.com>
 * @license    doc/LICENSE    Based New BSD License
 * @version    $Id: INI.php 4 2012-05-18 ccooffeee Exp $
 */

/** @namespace */
namespace CF\config\writer;

use CF\config\Config,
	CF\config\Writer,
	CF\exception\RuntimeException;


/**
 * @category   CF
 * @package    CF_config
 * @author     그네 Jung Sik, Park <ccooffeee@hotmail.com>
 * @copyright  Copyright (c) 2009 - 2012 Jung Sik, Park <ccooffeee@hotmail.com>
 * @license    doc/LICENSE    Based New BSD License
 */
class INI implements Writer
{

// {{{ properties 
	/** @var string */
	private $result;
// }}}


// {{{ construct (null|string filename, CF\config\Config config) 
	/**
	 * @param  string			filename
	 * @param  CF\config\Config	config
	 * @return void
	 * @throws CF\exception\RuntimeException
	 */
	public function __construct($filename, Config $config)
	{
		$ini = "; Generated by CF\\config\\Writer - ".date('Y-m-d H:i:s P T')."\n";

		// array
		$config = $this->_sort($config);
		foreach($config as $section => $data) {
			if(!is_array($data)) 
				$ini .= $section.' = '.$this->_escape($data)."\n";
			else $ini .= '['.$section.']'."\n"
						.$this->_appendGroup($data)."\n";
		}


		if($filename === null) {
			$this->result = $ini;
			return;
		}

		$result = @file_put_contents($filename, $ini);
		if($result === false)
			throw new RuntimeException("Cant write file '$filename'");
	}

// }}}


// {{{ __toString
	/**
	 * __toString magic method
	 *
	 * @return string
	 */
	public function __toString() {
		return (string) $this->result;
	}

// }}}


// {{{ private methods
	// {{{ string _appendGroup (array config [, array group])
	/**
	 * Recursive self call
	 *
	 * @param	array	config
	 * @param	array	group
	 * @return	string
	 */
    private function _appendGroup(array $config, $group = array())
    {
        $ini = '';
		foreach($config as $key => $value) {
			$_arr = array_merge($group, array($key));

			if(is_array($value))
				$ini .= $this->_appendGroup($value, $_arr);
			else $ini .= implode('.', $_arr).' = '.$this->_escape($value)."\n";
		}

		return $ini;
	}

	// }}}
	// {{{ mixed _escape (mixed value)

	/**
	 * Escape string
	 *
	 * @param  mixed value
	 * @return mixed
	 */
	private function _escape($value)
	{
		if(is_integer($value) || is_float($value)) 
			return $value;
		elseif(is_bool($value))
			return $value ? 'true' : 'false';
		else return '"'.addslashes($value).'"';
	}
	// }}}
	// {{{ array _sort (CF\config\Config config)

	/**
	 * Sort ini data
	 * Scalar value first, array last
	 *
	 * @param	CF\config\Config config
	 * @return	array
	 */
	private function _sort(Config $config)
	{
		$_config = array();

		foreach($config as $section => $data) {
			if($data instanceof Config) continue;
			$_config[$section] = $data;
		}
		foreach($config as $section => $data) {
			if($data instanceof Config) 
				$_config[$section] = $data->toArray();
		}

		return $_config;
	}
	// }}}
// }}}

}

// vim600: ts=4 sw=4 fdm=marker
?>
